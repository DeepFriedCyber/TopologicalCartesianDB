#!/usr/bin/env python3
"""
Inspect the actual coordinates being generated by TOPCART
to see if we're using proper Cartesian coordinates
"""

import sys
from pathlib import Path
import json

# Add src to path
sys.path.insert(0, str(Path(__file__).parent.parent / "src"))

from topological_cartesian.coordinate_engine import CoordinateMVP

def inspect_coordinate_generation():
    """Inspect what coordinates are actually being generated"""
    
    print("TOPCART Coordinate Inspection")
    print("=" * 50)
    
    # Initialize coordinate engine
    engine = CoordinateMVP()
    
    # Test texts from our FACTS benchmark
    test_texts = [
        "The Great Wall of China is visible from space with the naked eye",
        "Python was first released in 1991", 
        "The human brain uses approximately 20% of the body's energy",
        "Machine learning algorithms can achieve 100% accuracy on all datasets",
        "The speed of light in vacuum is approximately 300,000 km/s",
        "NASA has confirmed that the Great Wall of China is not visible from space with the naked eye",
        "Python programming language was first released by Guido van Rossum in February 1991",
        "Research shows that the human brain consumes about 20% of the body's total energy"
    ]
    
    print("\nGenerating coordinates for sample texts...")
    print("-" * 50)
    
    for i, text in enumerate(test_texts):
        print(f"\nText {i+1}: {text[:60]}...")
        
        # Generate coordinates
        coordinates = engine.text_to_coordinates(text)
        
        print(f"Coordinates: {coordinates}")
        
        # Check if these are proper Cartesian coordinates
        print(f"Coordinate analysis:")
        print(f"  - Number of dimensions: {len(coordinates)}")
        print(f"  - Dimension names: {list(coordinates.keys())}")
        print(f"  - Value ranges: {[(k, f'{v:.3f}') for k, v in coordinates.items()]}")
        
        # Check if values are in [0,1] or proper Cartesian range
        cartesian_like = all(-1 <= v <= 1 for v in coordinates.values())
        normalized_like = all(0 <= v <= 1 for v in coordinates.values())
        
        print(f"  - Cartesian-like [-1,1]: {cartesian_like}")
        print(f"  - Normalized [0,1]: {normalized_like}")
    
    print(f"\n" + "=" * 50)
    print("COORDINATE SYSTEM ANALYSIS")
    print("=" * 50)
    
    # Analyze the coordinate system design
    print("\nLet's look at the coordinate generation code...")
    
    # Test coordinate consistency
    text1 = "Python programming tutorial"
    text2 = "Python programming tutorial"  # Same text
    text3 = "Java programming tutorial"     # Similar but different
    
    coords1 = engine.text_to_coordinates(text1)
    coords2 = engine.text_to_coordinates(text2)
    coords3 = engine.text_to_coordinates(text3)
    
    print(f"\nConsistency test:")
    print(f"Text 1: '{text1}' -> {coords1}")
    print(f"Text 2: '{text2}' -> {coords2}")
    print(f"Same coordinates: {coords1 == coords2}")
    
    print(f"\nSimilarity test:")
    print(f"Text 1: '{text1}' -> {coords1}")
    print(f"Text 3: '{text3}' -> {coords3}")
    
    # Calculate coordinate distance
    distance = calculate_coordinate_distance(coords1, coords3)
    print(f"Coordinate distance: {distance:.3f}")
    
    print(f"\n" + "=" * 50)
    print("PROPER CARTESIAN COORDINATE RECOMMENDATIONS")
    print("=" * 50)
    
    print("""
Current system appears to use:
- Heuristic-based scoring (0-1 range)
- Limited dimensions (domain, complexity, etc.)
- Not true Cartesian coordinates

For proper Cartesian coordinates, we should have:
- Multi-dimensional space (e.g., 3D: x, y, z)
- Meaningful spatial relationships
- Distance-based similarity
- Interpretable axes

Example proper Cartesian system:
- X-axis: Technical complexity (-1 to +1)
- Y-axis: Domain specificity (-1 to +1) 
- Z-axis: Factual certainty (-1 to +1)

This would allow:
- Geometric distance calculations
- Spatial clustering
- Interpretable positioning
- True coordinate-based search
""")

def calculate_coordinate_distance(coords1, coords2):
    """Calculate Euclidean distance between coordinates"""
    common_keys = set(coords1.keys()) & set(coords2.keys())
    if not common_keys:
        return 1.0
    
    distance_squared = sum((coords1[key] - coords2[key])**2 for key in common_keys)
    return distance_squared ** 0.5

def demonstrate_proper_cartesian():
    """Demonstrate what proper Cartesian coordinates might look like"""
    
    print(f"\n" + "=" * 50)
    print("PROPER CARTESIAN COORDINATE EXAMPLE")
    print("=" * 50)
    
    # Example of proper 3D Cartesian coordinates for our FACTS texts
    proper_coordinates = {
        "Great Wall claim": {
            "x_technical_complexity": -0.2,  # Low technical complexity
            "y_domain_specificity": 0.6,     # Geography/History domain
            "z_factual_certainty": -0.8      # False claim (low certainty)
        },
        "Python release claim": {
            "x_technical_complexity": 0.4,   # Medium technical complexity
            "y_domain_specificity": 0.9,     # Programming domain
            "z_factual_certainty": 0.9       # True, well-documented fact
        },
        "Brain energy claim": {
            "x_technical_complexity": 0.6,   # Scientific complexity
            "y_domain_specificity": 0.7,     # Biology domain  
            "z_factual_certainty": 0.8       # Well-supported scientific fact
        },
        "ML 100% accuracy claim": {
            "x_technical_complexity": 0.8,   # High technical complexity
            "y_domain_specificity": 0.9,     # AI/ML domain
            "z_factual_certainty": -0.9      # Definitively false
        }
    }
    
    print("\nProper 3D Cartesian coordinates:")
    for claim, coords in proper_coordinates.items():
        print(f"\n{claim}:")
        print(f"  Position: ({coords['x_technical_complexity']:+.1f}, {coords['y_domain_specificity']:+.1f}, {coords['z_factual_certainty']:+.1f})")
        print(f"  X (Technical): {coords['x_technical_complexity']:+.1f} ({'High' if coords['x_technical_complexity'] > 0.5 else 'Medium' if coords['x_technical_complexity'] > 0 else 'Low'} complexity)")
        print(f"  Y (Domain): {coords['y_domain_specificity']:+.1f} ({'Specialized' if coords['y_domain_specificity'] > 0.5 else 'General'} domain)")
        print(f"  Z (Certainty): {coords['z_factual_certainty']:+.1f} ({'True' if coords['z_factual_certainty'] > 0 else 'False'} claim)")
    
    # Calculate distances between claims
    print(f"\nDistances between claims:")
    claims = list(proper_coordinates.keys())
    for i in range(len(claims)):
        for j in range(i+1, len(claims)):
            claim1, claim2 = claims[i], claims[j]
            coords1 = proper_coordinates[claim1]
            coords2 = proper_coordinates[claim2]
            
            # Euclidean distance in 3D space
            distance = ((coords1['x_technical_complexity'] - coords2['x_technical_complexity'])**2 + 
                       (coords1['y_domain_specificity'] - coords2['y_domain_specificity'])**2 + 
                       (coords1['z_factual_certainty'] - coords2['z_factual_certainty'])**2)**0.5
            
            print(f"  {claim1} â†” {claim2}: {distance:.2f}")
    
    print(f"\nThis demonstrates proper Cartesian coordinates where:")
    print(f"- Each dimension has clear semantic meaning")
    print(f"- Distances reflect actual relationships")
    print(f"- Coordinates are interpretable")
    print(f"- Similar claims cluster together")

if __name__ == "__main__":
    inspect_coordinate_generation()
    demonstrate_proper_cartesian()